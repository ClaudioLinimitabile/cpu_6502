#pragma once
#include "BUS.h"

struct STATUSREGISTER{
    bool N; //NEGATIVE
    bool V; //OVERFLOW
    bool B; //BREAK
    bool D; //DECIMAL
    bool I; //INTERRUPT
    bool Z; //ZERO
    bool C; //CARRY
};

class cpu_6502{ //NO ACCURATE CYCLE EMULATION AT THE MOMENT WILL IMPLEMENT IT LATER//
    public:
    cpu_6502(); //CONSTRUCTOR
    BUS bus;

    typedef void (cpu_6502::*func)();
    func table[256]; //SETTING UP FUNCTION TABLE

    //DATA//
    uint16_t PC; //PROGRAM COUNTER
    uint8_t SP; //STACK POINTER
    uint8_t A; //ACCUMULATOR
    uint8_t X; //X REGISTER
    uint8_t Y; //Y REGISTER
    STATUSREGISTER ST; //STATUS FLAGS

    //METHOD//
    uint8_t FetchByte(); //GET THE BYTE FROM RAM AT THE LOCATION POINTED BY PC THEN INCREMENTS IT READY FOR OTHER FETCH
    void INIT_TABLE(); //INITIALIZE THE FUNCTION TABLE
    void STEP(); //ONE INSTRUCTION
    void RESET(uint16_t START = 0, bool autoset=true);
    void DEBUGSCREN();

    //ADDRESSING MODE// 
    //NOTE: THE ADDRESSING MODE IS A RETURNING ADDRES TO FETCH FOR NEEDED OPERAND IT CAN BE DIFFERENT FOR ALL THE INSTRUCTION 
    //!!GETS ONLY THE OPERAND IT DOES NOT THE ISTRUCTION!! BY DOING SO IT INCREMENT THE PC IF IS NEEDED
    //REMEMBER: NO NEED TO INCREMENT PC COUSE FETCH WILL!

    uint16_t Immediate();   //RETURN IMMEDIATE ADDRES AFTER THE OPCODE
    uint16_t Absolute();    //RETURN ADDRES FORMED BY 2 BYTE AFTER OPCODE IN THE FORM OF LLHH (little endian)
    uint16_t ZeroPage();    //RETURN ADDRES FORMED BY 1 BYTE AFTER OPCODE IN THIS WAY 00xx
    uint16_t AbsoluteX();   //RETURN ADDRES FORMED BY 2 BYTE AFTER OPCODE IN THE FORM OF LLHH (little endian) PLUS THE VALUE OF X
    uint16_t AbsoluteY();   //RETURN ADDRES FORMED BY 2 BYTE AFTER OPCODE IN THE FORM OF LLHH (little endian) PLUS THE VALUE OF Y
    uint16_t ZeropageX();   //RETURN ADDRES FORMED BY 1 BYTE AFTER OPCODE IN THIS WAY 00xx PLUS THE VALUE OF X
    uint16_t ZeropageY();   //RETURN ADDRES FORMED BY 1 BYTE AFTER OPCODE IN THIS WAY 00xx PLUS THE VALUE OF Y
    uint16_t Indirect();    //RETURN ADDRES POINTED BY ANOTHER ADDRES FORMED BY 2 BYTE IN THE FORM OF LLHH (little endian)
    uint16_t IndirectZPX(); //SIMILAR TO INDIRECT BUT FORMS THE ADDRES LOOKUP WITH ONE BYTE PLUS X
    uint16_t IndirectZPY(); //SIMILAR TO INDIRECT BUT AFTER WE GET THE LOOKUP ADDRES WE INCREMENT IT BY Y
    uint16_t Relative();    //RETURN OFFSET OF PC
    //IF IMPLIED OR ACCUMULATOR JUST FETCH//

    //OPCODE//

    void ADC_IMM();    //ADD WITH CARRY IMMEDIATE
    void ADC_ZP();     //ADD WITH CARRY ZEROPAGE
    void ADC_ZPX();    //ADD WITH CARRY ZEROPAGE X
    void ADC_ABS();    //ADD WITH CARRY ABSOLUTE
    void ADC_ABSX();   //ADD WITH CARRY ABSOLUTE X
    void ADC_ABSY();   //ADD WITH CARRY ABSOLUTE Y
    void ADC_INDZPX(); //ADD WITH CARRY INDIRECT ZEROPAGE X
    void ADC_INDZPY(); //ADD WITH CARRY INDIRECT ZEROPAGE Y
    void AND_IMM();    //BITWISE AND IMMEDIATE
    void AND_ZP();     //BITWISE AND ZEROPAGE
    void AND_ZPX();    //BITWISE AND ZEROPAGE X
    void AND_ABS();    //BITWISE AND ABSOLUTE
    void AND_ABSX();   //BITWISE AND ABSOLUTE X
    void AND_ABSY();   //BITWISE AND ABSOLUTE Y
    void AND_INDZPX(); //BITWISE AND INDIRECT ZEROPAGE X
    void AND_INDZPY(); //BITWISE AND INDIRECT ZEROPAGE Y
    void ASL_AC();     //ARITMETIC SHIFT LEFT ACCUMULATOR (IMPLIED)
    void ASL_ZP();     //ARITMETIC SHIFT LEFT ZEROPAGE
    void ASL_ZPX();    //ARITMETIC SHIFT LEFT ZEROPAGE X
    void ASL_ABS();    //ARITMETIC SHIFT LEFT ABSOLUTE
    void ASL_ABSX();   //ARITMETIC SHIFT LEFT ABSOLUTE X
    void BCC_REL();    //BRANCH IF CARRY CLEAR RELATIVE
    void BCS_REL();    //BRANCH IF CARRY SET RELATIVE
    void BEQ_REL();    //BRANCH IF EQUAL RELATIVE
    void BIT_ZP();     //BIT TEST ZEROPAGE
    void BIT_ABS();    //BIT TEST ABSOLUTE
    void BMI_REL();    //BRANCH IF MINUS RELATIVE
    void BNE_REL();    //BRANCH IF NOT EQUAL
    void BPL_REL();    //BRANCH IF PLUS
    void BRK();        //BREAK (SOFTWARE IRQ)
    void BVC_REL();    //BRANCH IF OVERFLOW CLEAR RELATIVE
    void BVS_REL();    //BRANCH IF OVERFLOW SET RELATIVE
    void CLC_IMPL();   //CLEAR CARRY IMPLIED
    void CLD_IMPL();   //CLEAR DECIMAL IMPLIED
    void CLI_IMPL();   //CLEAR INTERRUPT DISABLE IMPLIED
    void CLV_IMPL();   //CLEAR OVERFLOW IMPLIED
    void CMP_IMM();    //COMPARE A IMMEDIATE
    void CMP_ZP();     //COMPARE A ZEROPAGE
    void CMP_ZPX();    //COMPARE A ZEROPAGE X
    void CMP_ABS();    //COMPARE A ABSOLUTE
    void CMP_ABSX();   //COMPARE A ABSOLUTE X
    void CMP_ABSY();   //COMPARE A ABSOLUTE Y
    void CMP_INDZPX(); //COMPARE A INDIRECT ZEROPAGE X
    void CMP_INDZPY(); //COMPARE A INDIRECT ZEROPAGE Y
    void CPX_IMM();    //COMPARE X IMMEDIATE
    void CPX_ZP();     //COMPARE X ZEROPAGE
    void CPX_ABS();    //COMPARE X ABSOLUTE
    void CPY_IMM();    //COMPARE Y IMMEDIATE
    void CPY_ZP();     //COMPARE Y ZEROPAGE
    void CPY_ABS();    //COMPARE Y ABSOLUTE
    void DEC_ZP();     //DECREMENT MEMORY ZEROPAGE
    void DEC_ZPX();    //DECREMENT MEMORY ZEROPAGE X
    void DEC_ABS();    //DECREMENT MEMORY ABSOLUTE
    void DEC_ABSX();   //DECREMENT MEMORY ABSOLUTE X
    void DEX_IMPL();   //DECREMENT X IMPLIED
    void DEY_IMPL();   //DECREMENT Y IMPLIED
    void EOR_IMM();    //BITWISE EXLUSIVE OR IMMEDIATE
    void EOR_ZP();     //BITWISE EXLUSIVE OR ZEROPAGE
    void EOR_ZPX();    //BITWISE EXLUSIVE OR ZEROPAGE X
    void EOR_ABS();    //BITWISE EXLUSIVE OR ABSOLUTE
    void EOR_ABSX();   //BITWISE EXLUSIVE OR ABSOLUTE X
    void EOR_ABSY();   //BITWISE EXLUSIVE OR ABSOLUTE Y
    void EOR_INDZPX(); //BITWISE EXLUSIVE OR INDIRECT ZEROPAGE X
    void EOR_INDZPY(); //BITWISE EXLUSIVE OR INDIRECT ZEROPAGE Y
    void INC_ZP();     //INCREMENT MEMORY ZEROPAGE
    void INC_ZPX();    //INCREMENT MEMORY ZEROPAGE X
    void INC_ABS();    //INCREMENT MEMORY ABSOLUTE
    void INC_ABSX();   //INCREMENT MEMORY ABSOLUTE X
    void INX_IMPL();   //INCREMENT X
    void INY_IMPL();   //INCREMENT Y
    void JMP_ABS();    //JUMP ABSOLUTE
    void JMP_IND();    //JUMP INDIRECT
    void JSR_ABS();    //JUMP TO SUB ROUTINE
    void LDA_IMM();    //LOAD A IMMEDIATE
    void LDA_ZP();     //LOAD A ZEROPAGE
    void LDA_ZPX();    //LOAD A ZEROPAGE X
    void LDA_ABS();    //LOAD A ABSOLUTE
    void LDA_ABSX();   //LOAD A ABSOLUTE X
    void LDA_ABSY();   //LOAD A ABSOLUTE Y
    void LDA_INDZPX(); //LOAD A INDIRECT ZEROPAGE X
    void LDA_INDZPY(); //LOAD A INDIRECT ZEROPAGE Y
    void LDX_IMM();    //LOAD X IMMEDIATE
    void LDX_ZP();     //LOAD X ZEROPAGE
    void LDX_ZPY();    //LOAD X ZEROPAGE Y
    void LDX_ABS();    //LOAD X ABSOLUTE
    void LDX_ABSY();   //LOAD X ABSOLUTE Y
    void LDY_IMM();    //LOAD Y IMMEDIATE
    void LDY_ZP();     //LOAD Y ZEROPAGE
    void LDY_ZPX();    //LOAD Y ZEROPAGE X
    void LDY_ABS();    //LOAD Y ABSOLUTE
    void LDY_ABSX();   //LOAD Y ABSOLUTE X
    void LSR_AC();     //LOGICAL SHIFT RIGHT ACUMULATOR (implied)
    void LSR_ZP();     //LOGICAL SHIFT RIGHT ZEROPAGE
    void LSR_ZPX();    //LOGICAL SHIFT RIGHT ZEROPAGE X
    void LSR_ABS();    //LOGICAL SHIFT RIGHT ABSOLUTE
    void LSR_ABSX();   //LOGICAL SHIFT RIGHT ABSOLUTE X
    void NOP();        //NO OPERATION IMPLIED
    void ORA_IMM();    //BITWISE OR IMMEDIATE
    void ORA_ZP();     //BITWISE OR ZEROPAGE
    void ORA_ZPX();    //BITWISE OR ZEROPAGE X
    void ORA_ABS();    //BITWISE OR ABSOLUTE
    void ORA_ABSX();   //BITWISE OR ABSOLUTE X
    void ORA_ABSY();   //BITWISE OR ABSOLUTE Y
    void ORA_INDZPX(); //BITWISE OR INDIRECT ZEROPAGE X
    void ORA_INDZPY(); //BITWISE OR INDIRECT ZEROPAGE Y
    void PHA_IMPL();   //PUSH A IMPLIED
    void PHP_IMPL();   //PUSH PROCESSOR STATUS IMPLIED
    void PLA_IMPL();   //PULL A IMPLIED
    void PLP_IMPL();   //PUL PROCESSOR STATUS IMPLIED
    void ROL_AC();     //ROTATE LEFT ACCUMULATOR
    void ROL_ZP();     //ROTATE LEFT ZEROPAGE
    void ROL_ZPX();    //ROTATE LEFT ZEROPAGE X
    void ROL_ABS();    //ROTATE LEFT ABSOLUTE
    void ROL_ABSX();   //ROTATE LEFT ABSOLUTE X
    void ROR_AC();     //ROTATE RIGHT ACCUMULATOR;
    void ROR_ZP();     //ROTATE RIGHT ZEROPAGE
    void ROR_ZPX();    //ROTATE RIGHT ZEROPAGE X
    void ROR_ABS();    //ROTATE RIGHT ABSOLUTE
    void ROR_ABSX();   //ROTATE RIGHT ABSOLUTE X
    void RTI_IMPL();   //RETURN FROM INTERRUPT IMPLIED
    void RTS_IMPL();   //RETURN FROM SUBRUTINE IMPLIED
    void SBC_IMM();    //SUBTRACT WITH CARRY IMMEDIATE
    void SBC_ZP();     //SUBTRACT WITH CARRY ZEROPAGE
    void SBC_ZPX();    //SUBTRACT WITH CARRY ZEROPAGE X
    void SBC_ABS();    //SUBTRACT WITH CARRY ABSOLUTE
    void SBC_ABSX();   //SUBTRACT WITH CARRY ABSOLUTE X
    void SBC_ABSY();   //SUBTRACT WITH CARRY ABSOLUTE Y
    void SBC_INDZPX(); //SUBTRACT WITH CARRY INDIRECT ZEROPAGE X
    void SBC_INDZPY(); //SUBTRACT WITH CARRY INDIRECT ZEROPAGE Y
    void SEC_IMPL();   //SET CARRY IMPLIED
    void SED_IMPL();   //SET DECIMAL IMPLIED
    void SEI_IMPL();   //SET INTERRUPR DISABLE IMPLIED
    void STA_ZP();     //STORE A ZEROPAGE
    void STA_ZPX();    //STORE A ZEROPAGE X
    void STA_ABS();    //STORE A ABSOLUTE
    void STA_ABSX();   //STORE A ABSOLUTE X
    void STA_ABSY();   //STORE A ABSOLUTE Y
    void STA_INDZPX(); //STORE A INDIRECT ZEROPAGE X
    void STA_INDZPY(); //STORE A INDIRECT ZEROPAGE Y
    void STX_ZP();     //STROE X ZEROPAGE
    void STX_ZPY();    //STROE X ZEROPAGE Y
    void STX_ABS();    //STROE X ABSOLUTE
    void STY_ZP();     //STROE Y ZEROPAGE
    void STY_ZPX();    //STROE Y ZEROPAGE X
    void STY_ABS();    //STROE Y ABSOLUTE
    void TAX_IMPL();   //TRANSFER A TO X IMPLIED
    void TAY_IMPL();   //TRANSFER A TO Y IMPLIED
    void TSX_IMPL();   //TRANSFER STACK POINTER TO X IMPLIED
    void TXA_IMPL();   //TRANSFER X TO A IMPLIED
    void TXS_IMPL();   //TRANSFER X TO STACK POINTER IMPLIED
    void TYA_IMPL();   //TRANSFER Y TO A IMPLIED
};